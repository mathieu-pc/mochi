def directAdaptiveOpticallyThin(cells, xyzRange, cellUnit, fieldMHI, fieldV, fieldT, channelSize, dtype = np.uintc):
	xyz0 = np.min(cells, axis = 0)
	dx = xyz0[-1]
	elementVolume = dx ** 3 * cellUnit ** 3
	xyz0[-1] = 0
	grid_shape = [ int((myRange[1]-myRange[0])//dx) for myRange in xyzRange]
	N = len(cells)
	cellRange = np.arange(N, dtype = dtype)
	cellsBegin = np.round((cells[:,:-1] - xyz0[:-1])/dx).astype(dtype)
	cellsFinish = np.round((cells[:,:-1] - xyz0[:-1] + cells[:,-1][:,np.newaxis])/dx).astype(dtype)
	fieldSpectra = calculateFieldSpectrum(fieldMHI, fieldV, fieldT, elementVolume, channelSize)
	cubeUnit = fieldSpectra.unit
	fieldSpectra *= cellsFinish[:,0] - cellsBegin[:,0]
	fieldSpectra = fieldSpectra[:,:,None,None].value
	cube = np.zeros((fieldSpectra.shape[0], grid_shape[1], grid_shape[2]))
	for i in cellRange:
		x_start, y_start, z_start = cellsBegin[i]
		x_end, y_end, z_end = cellsFinish[i]
		cube[:,y_start:y_end, z_start:z_end] += fieldSpectra[:,i]
	return cube * cubeUnit
